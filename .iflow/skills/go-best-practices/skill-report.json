{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T08:45:26.527Z",
    "slug": "0xbigboss-go-best-practices",
    "source_url": "https://github.com/0xBigBoss/claude-code/tree/main/.claude/skills/go-best-practices",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1c44e581c2a3bf1c578ca8e7f8b1dfeb02bf93329498e88227672d71d615f057",
    "tree_hash": "d14483b4e59cc6baf7b26ac36879b0713061c1ea1af240ae7137156c6864a52f"
  },
  "skill": {
    "name": "go-best-practices",
    "description": "Provides Go patterns for type-first development with custom types, interfaces, functional options, and error handling. Must use when reading or writing Go files.",
    "summary": "Provides Go patterns for type-first development with custom types, interfaces, functional options, a...",
    "icon": "ðŸ”·",
    "version": "1.0.0",
    "author": "0xBigBoss",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "Go",
      "programming",
      "best-practices",
      "type-system",
      "patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based documentation skill containing only markdown guidance for Go programming patterns. No executable code, network calls, file system access, or command execution capabilities.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 270,
    "audit_model": "claude",
    "audited_at": "2026-01-10T08:45:26.527Z"
  },
  "content": {
    "user_title": "Apply Go best practices for type-safe code",
    "value_statement": "Go projects often suffer from runtime errors that could be caught at compile time. This skill provides patterns for type-first development, interfaces, functional options, and proper error handling to prevent bugs before they happen.",
    "seo_keywords": [
      "Go best practices",
      "Go patterns",
      "type-first development",
      "Claude Code",
      "Claude",
      "Codex",
      "Go interfaces",
      "functional options Go",
      "Go error handling",
      "Go programming"
    ],
    "actual_capabilities": [
      "Guide type-first development with custom types and structs",
      "Define interfaces for behavior contracts",
      "Implement functional options pattern for flexible configuration",
      "Apply proper error handling with context and wrapping",
      "Structure Go modules with cohesive package design",
      "Create exhaustive switch statements with default error handling"
    ],
    "limitations": [
      "Does not execute or test Go code",
      "Does not provide compiler or tooling",
      "Does not integrate with Go modules or dependencies",
      "Does not generate complete project scaffolds"
    ],
    "use_cases": [
      {
        "target_user": "Go developers",
        "title": "Write type-safe Go code",
        "description": "Design data structures and interfaces before implementation to make illegal states unrepresentable."
      },
      {
        "target_user": "Backend engineers",
        "title": "Build maintainable APIs",
        "description": "Create clean error handling patterns and functional options for configurable server implementations."
      },
      {
        "target_user": "AI assistants",
        "title": "Generate idiomatic Go",
        "description": "Follow established Go conventions when writing or reviewing Go code for any project."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic type design",
        "scenario": "Designing a new data model",
        "prompt": "Design a type-safe Go struct for a [entity] with proper custom types for domain primitives. Include validation at construction and proper error handling."
      },
      {
        "title": "Interface definition",
        "scenario": "Defining behavior contracts",
        "prompt": "Define a Go interface for a [repository/service] that accepts context and returns typed results. Show how to accept interfaces and return structs."
      },
      {
        "title": "Functional options",
        "scenario": "Creating configurable constructors",
        "prompt": "Implement a NewServer function using the functional options pattern with sensible defaults. Include examples for port, timeout, and custom configuration."
      },
      {
        "title": "Complete implementation",
        "scenario": "Building a full Go package",
        "prompt": "Implement a complete Go package following type-first development: define types first, create interfaces, implement error wrapping with %w, and add table-driven tests."
      }
    ],
    "output_examples": [
      {
        "input": "Create a User type with email validation and proper error handling",
        "output": [
          "type UserID string - prevents mixing UserID with other string IDs",
          "type User struct with embedded Timestamps for created/updated tracking",
          "func NewUser(req CreateUserRequest) error that validates email format",
          "Returns typed errors with context using fmt.Errorf and %w",
          "Switch statement with exhaustive cases and default error branch"
        ]
      }
    ],
    "best_practices": [
      "Define types and interfaces before implementation to let the compiler guide completeness.",
      "Accept interfaces, return structs to maximize flexibility while controlling API surface.",
      "Return new values instead of mutating inputs to make data flow explicit."
    ],
    "anti_patterns": [
      "Using generic types like string or int instead of domain-specific custom types.",
      "Returning errors without context using bare errors.New without wrapping.",
      "Skipping default cases in switch statements, allowing silent failures."
    ],
    "faq": [
      {
        "question": "Does this skill work with Go 1.18+ generics?",
        "answer": "Yes. The patterns focus on type-first development. Generics can complement custom types when appropriate."
      },
      {
        "question": "What Go versions are supported?",
        "answer": "Go 1.17 and later. Error wrapping with %w requires Go 1.13+."
      },
      {
        "question": "Can this integrate with my existing Go project?",
        "answer": "This is a prompt skill. It guides AI assistants working on your code but does not modify files directly."
      },
      {
        "question": "Is any data sent to external servers?",
        "answer": "No. This skill contains only documentation patterns. No network calls or data transmission occurs."
      },
      {
        "question": "How does this compare to golangci-lint?",
        "answer": "This skill provides design patterns. golangci-lint enforces code quality. Use both together."
      },
      {
        "question": "Should I use this for every Go file?",
        "answer": "Load this skill when working with Go files. The patterns apply to most Go code you write."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
